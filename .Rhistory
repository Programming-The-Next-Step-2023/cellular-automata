sum(input_matrix[nrow(input_matrix), ]) > 0 ||
sum(input_matrix[, 1]) > 0 ||
sum(input_matrix[, ncol(input_matrix)]) > 0
) {
output_matrix = input_matrix
border_reached = TRUE
} else {  # Otherwise apply rule set
rules = extract_rules(rule_string)
# Which dead cells are born into life?
list_dead = which(input_matrix == 0)
for (i in list_dead) {
# Indices of cell
number_of_rows = nrow(input_matrix)
row_index = i %% number_of_rows
column_index = ceiling(i / number_of_rows)
living_neighbours = neighbours(input_matrix, row_index, column_index)
if (living_neighbours %in% rules[[1]]) {  # Birth rules met?
output_matrix[i] = 1
}
}
# End of birth computation
# Which living cells survive?
list_living = which(input_matrix == 1)
for (i in list_living) {
# Indices of cell
number_of_rows = nrow(input_matrix)
row_index = i %% number_of_rows
column_index = ceiling(i / number_of_rows)
living_neighbours = neighbours(input_matrix, row_index, column_index)
if (living_neighbours %in% rules[[2]]) {  # Survival rules met?
output_matrix[i] = 1
}
}
# End survival computation
}
# End computation output_matrix
return(list(output_matrix, border_reached))
}
evolve(simple_glider, rules)
evolve(simple_glider, rules)[[2]]
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
while (ticks < max_iterations) {
border_reached = evolve(current_matrix, rules)[[2]]
next_matrix = evolve(current_matrix, rules)[[1]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 10)
draw_pixels(beehive)
automaton(beehive, "B3/S23", max_iterations = 50, speed = 5)
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 50, speed = 5)  # Life
automaton(toad, "B2/S", max_iterations = 50, speed = 5)  # Seeds
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (ticks < max_iterations && border_reached == FALSE) {
next_matrix = evolve(current_matrix, rules)[[1]]
next_matrix = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 1)
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (ticks < max_iterations && border_reached == FALSE) {
next_matrix = evolve(current_matrix, rules)[[1]]
next_matrix = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 1)
automaton(glider, "B3/S23", max_iterations = 100, speed = 1)
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (ticks < max_iterations && border_reached == FALSE) {
next_matrix = evolve(current_matrix, rules)[[1]]
next_matrix = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
debug(automaton)
automaton(glider, "B3/S23", max_iterations = 100, speed = 1)
all.equal(current_matrix, next_matrix)
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (ticks < max_iterations && border_reached == FALSE) {
next_matrix = evolve(current_matrix, rules)[[1]]
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 1)
automaton(glider, "B3/S23", max_iterations = 100, speed = 10)
draw_pixels(toad)
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 50, speed = 5)  # Life
q
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 50, speed = 5)  # Life
Q
q
print("hello")
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 50, speed = 5)  # Life
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (ticks < max_iterations && border_reached == FALSE) {
next_matrix = evolve(current_matrix, rules)[[1]]
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 50, speed = 5)  # Life
automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (border_reached == FALSE && ticks < max_iterations) {
next_matrix = evolve(current_matrix, rules)[[1]]
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else if (ticks >= max_iterations) {
print(paste0("Maximum Iterations reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
}
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
automaton <- function(input_matrix, rules, max_iterations, speed) {
ticks = 0
current_matrix = input_matrix
border_reached = evolve(current_matrix, rules)[[2]]
while (border_reached == FALSE && ticks < max_iterations) {
next_matrix = evolve(current_matrix, rules)[[1]]
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
print(paste0("Border was reached."))
} else {
ticks = ticks + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
return(NULL)  # placeholder for list which will contain values for GUI or something
}
automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
automaton <- function(input_matrix, rules, max_iterations, speed) {
iteration = 0
current_matrix = input_matrix
# Living border cells in the INITIAL matrix?
border_reached = evolve(current_matrix, rules)[[2]]
while (border_reached == FALSE && iteration < max_iterations) {
next_matrix = evolve(current_matrix, rules)[[1]]
# Living border cells in the NEXT matrix?
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
break
} else {
iteration = iteration + 1
print(paste0("Time: ", ticks))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
# End while loop
if (border_reached == TRUE) {
print(paste0("Border was reached."))
}
if (iteration >= max_iterations) {
print(paste0("Maximum number of iterations reached."))
}
return()  # placeholder for list which will contain values for GUI
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 10)
automaton <- function(input_matrix, rules, max_iterations, speed) {
iteration = 0
current_matrix = input_matrix
# Living border cells in the INITIAL matrix?
border_reached = evolve(current_matrix, rules)[[2]]
while (border_reached == FALSE && iteration < max_iterations) {
next_matrix = evolve(current_matrix, rules)[[1]]
# Living border cells in the NEXT matrix?
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
break
} else {
iteration = iteration + 1
print(paste0("Time: ", iterations))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
# End while loop
if (border_reached == TRUE) {
print(paste0("Border was reached."))
}
if (iteration >= max_iterations) {
print(paste0("Maximum number of iterations reached."))
}
return()  # placeholder for list which will contain values for GUI
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 10)
automaton <- function(input_matrix, rules, max_iterations, speed) {
iteration = 0
current_matrix = input_matrix
# Living border cells in the INITIAL matrix?
border_reached = evolve(current_matrix, rules)[[2]]
while (border_reached == FALSE && iteration < max_iterations) {
next_matrix = evolve(current_matrix, rules)[[1]]
# Living border cells in the NEXT matrix?
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
break
} else {
iteration = iteration + 1
print(paste0("Time: ", iteration))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
# End while loop
if (border_reached == TRUE) {
print(paste0("Border was reached."))
}
if (iteration >= max_iterations) {
print(paste0("Maximum number of iterations reached."))
}
return()  # placeholder for list which will contain values for GUI
}
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 10)
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
automaton(toad, "B2/S", max_iterations = 50, speed = 5)  # Seeds
automaton(toad, "B2/S", max_iterations = 3, speed = 5)  # Seeds
draw_pixels(beehive)
automaton(beehive, "B3/S23", max_iterations = 50, speed = 5)
automaton(beehive, "B3/S23", max_iterations = 7, speed = 5)
draw_pixels(glider)
draw_pixels(glider)
automaton(glider, "B3/S23", max_iterations = 100, speed = 15)
draw_pixels(toad)
automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
automaton(toad, "B2/S", max_iterations = 50, speed = 5)  # Seeds
draw_pixels(beehive)
automaton(beehive, "B3/S23", max_iterations = 7, speed = 5)
gustaws_game = click_pixels(30, 30)
gustaws_game = click_pixels(30, 30)
gustaws_game = click_pixels(30, 30)
#
#
# Shiny Life-Like Cells: Computations
#
# all the vitals for an Automaton
# Source -----------------------------------------------------------------------
source("./R/pixeltrix.R")
# Load test_matrices
test_matrices = as.list(dir(path = "./data/test_matrices"))
for (i in 1:length(test_matrices)) {
file_path = paste0("./data/test_matrices/", test_matrices[i])
load(file_path)
}
# neighbours() -----------------------------------------------------------------
# Counts living neighbours in a cell´s Moore neighbourhood
neighbours <- function(matrix, row_index, col_index) {
living = 0
# Use try() because of cells at borders who have < 8 neighbour cells
# silent = TRUE because each matrix has border cells and will thus produce
# errors
try(
if (matrix[row_index - 1, col_index - 1]) living = living + 1,  # North-West
silent = TRUE
)
try(
if (matrix[row_index - 1, col_index]) living = living + 1,  # North
silent = TRUE
)
try(
if (matrix[row_index - 1, col_index + 1]) living = living + 1,  # North-East
silent = TRUE
)
try(
if (matrix[row_index, col_index - 1]) living = living + 1,  # West
silent = TRUE
)
try(
if (matrix[row_index, col_index + 1]) living = living + 1,  # East
silent = TRUE
)
try(
if (matrix[row_index + 1, col_index - 1]) living = living + 1,  # South-West
silent = TRUE
)
try(
if (matrix[row_index + 1, col_index]) living = living + 1,  # South
silent = TRUE
)
try(
if (matrix[row_index + 1, col_index + 1]) living = living + 1,  # South-East
silent = TRUE
)
return(living)
}
testthat::expect_equal(neighbours(border_north_east, 1, 1), 1)
testthat::expect_equal(neighbours(border_north, 1, 5), 5)
testthat::expect_equal(neighbours(border_north_west, 1, 2), 1)
testthat::expect_equal(neighbours(border_west, 8, 1), 2)
testthat::expect_equal(neighbours(border_east, 8, 8), 2)
testthat::expect_equal(neighbours(border_south_west, 7, 8), 3)
testthat::expect_equal(neighbours(border_south, 3, 2), 1)
testthat::expect_equal(neighbours(border_south_east, 5, 1), 1)
# extract_rules() --------------------------------------------------------------
# Takes a string of rules in Golly/RLE format as input
# and returns a list with two vectors.
# First vector contains birth_rules
# Second contains the survival_rules
extract_rules <- function(input_string) {
separated_rules = unlist(strsplit(input_string, "/"))
birth_rules = separated_rules[1]
birth_rules = unlist(strsplit(birth_rules, ""))
birth_rules = as.integer(birth_rules[-1])
survival_rules = separated_rules[2]
survival_rules = unlist(strsplit(survival_rules, ""))
survival_rules = as.integer(survival_rules[-1])
return(list(birth_rules, survival_rules))
}
# evolve() ---------------------------------------------------------------------
# Takes a matrix and rule set as input
# returns list with matrix after evolution AND whether border was reached
evolve <- function(input_matrix, rule_string) {
output_matrix = input_matrix
output_matrix[output_matrix == 1] <- 0
border_reached = FALSE
# Border cells alive? -> no change through evolution
if (
sum(input_matrix[1, ]) > 0 ||
sum(input_matrix[nrow(input_matrix), ]) > 0 ||
sum(input_matrix[, 1]) > 0 ||
sum(input_matrix[, ncol(input_matrix)]) > 0
) {
output_matrix = input_matrix
border_reached = TRUE
} else {  # Otherwise apply rule set
rules = extract_rules(rule_string)
# Which dead cells are born into life?
list_dead = which(input_matrix == 0)
for (i in list_dead) {
# Indices of cell
number_of_rows = nrow(input_matrix)
row_index = i %% number_of_rows
column_index = ceiling(i / number_of_rows)
living_neighbours = neighbours(input_matrix, row_index, column_index)
if (living_neighbours %in% rules[[1]]) {  # Birth rules met?
output_matrix[i] = 1
}
}
# End of birth computation
# Which living cells survive?
list_living = which(input_matrix == 1)
for (i in list_living) {
# Indices of cell
number_of_rows = nrow(input_matrix)
row_index = i %% number_of_rows
column_index = ceiling(i / number_of_rows)
living_neighbours = neighbours(input_matrix, row_index, column_index)
if (living_neighbours %in% rules[[2]]) {  # Survival rules met?
output_matrix[i] = 1
}
}
# End survival computation
}
# End computation output_matrix
return(list(output_matrix, border_reached))
}
# automaton() ------------------------------------------------------------------
#
automaton <- function(input_matrix, rules, max_iterations, speed) {
iteration = 0
current_matrix = input_matrix
# Living border cells in the INITIAL matrix?
border_reached = evolve(current_matrix, rules)[[2]]
while (border_reached == FALSE && iteration < max_iterations) {
next_matrix = evolve(current_matrix, rules)[[1]]
# Living border cells in the NEXT matrix?
border_reached = evolve(current_matrix, rules)[[2]]
if (border_reached == TRUE) {
break
} else {
iteration = iteration + 1
print(paste0("Time: ", iteration))
draw_pixels(next_matrix)
current_matrix = next_matrix
Sys.sleep(1 / speed)
}
}
# End while loop
if (border_reached == TRUE) {
print(paste0("Border was reached."))
}
if (iteration >= max_iterations) {
print(paste0("Maximum number of iterations reached."))
}
return()  # placeholder for list which will contain values for GUI
}
#draw_pixels(glider)
#automaton(glider, "B3/S23", max_iterations = 100, speed = 15)
#draw_pixels(toad)
#automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
#automaton(toad, "B2/S", max_iterations = 50, speed = 5)  # Seeds
#automaton(toad, "B2/S", max_iterations = 3, speed = 5)  # Seeds
#draw_pixels(beehive)
#automaton(beehive, "B3/S23", max_iterations = 7, speed = 5)
gustaws_game = click_pixels(30, 30)
draw_pixels(gustaws_game)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
gustaws_game = click_pixels(30, 30)
draw_pixels(gustaws_game)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
gustaws_game = click_pixels(30, 30)
draw_pixels(gustaws_game)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
draw_pixels(gustaws_game)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
draw_pixels(toad)
#automaton(toad, "B3/S23", max_iterations = 15, speed = 5)  # Life
automaton(toad, "B2/S", max_iterations = 50, speed = 5)  # Seeds
library(livelycells)
play()
draw_pixels(gustaws_game)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
automaton(gustaws_game, "B3/S23", max_iterations = 100, speed = 10)
